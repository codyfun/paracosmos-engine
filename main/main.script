require "main/util"
require "main/gamelogic"
gooey = require "gooey.gooey"
mapper = require "in.mapper"
triggers = require "in.triggers"
richtext = require "richtext.richtext"
monarch = require "monarch.monarch"
monarch.transitions = require "monarch.transitions.gui"

ModStat = require "main/modstat"
HookFunc = require "main/hookfunc"

Player = require "main/classes/player"
Battler = require "main/classes/battler"

content = {}
content.formulas = require"content/formulas"
content.skills = require "content/skills"
content.statuses = require "content/statuses"
content.perks = require "content/perks"
content.chars = require "content/chars"

Game = {}
Game.RNG = {}
Game.Options = {}
Game.Party = {}
Game.Inventory = {}
Game.Encounter = {}

Engine = {}
function Engine.load_texture (self, path)
	if not self.loaded_textures then self.loaded_textures = {} end
    if not self.loaded_textures[path] then
		local icon_data = sys.load_resource("/content/images/" .. path .. ".png") -- TODO: game.project:Custom Resources powers the HTML5 build. Remove when switching to Desktop mod support.
		if not icon_data and (sys.get_sys_info().system_name ~= "HTML5") then
            icon_file = io.open("content/images/" .. path .. ".png", "rb")
			icon_data = icon_file:read("*a")
			icon_file.close()
		end
		if icon_data then
			local rawimg = image.load(icon_data)
			gui.new_texture(path, rawimg.width, rawimg.height, rawimg.type, rawimg.buffer)
            self.loaded_textures[path] = true
			return true
        end
    else
		return true
	end
end
function Engine.richtext_autoscale (self, node, text, base_scale, base_width)
	if not self.rich_text_nodes then self.rich_text_nodes = {} end
	for i, old_data in pairs(self.rich_text_nodes) do
		if old_data[1] == node then
			richtext.remove(old_data[2])
			table.remove(self.rich_text_nodes, i)
			if old_data[4].valign == richtext.VALIGN_BOTTOM then
				gui.set_position(node, gui.get_position(node) - vmath.vector3(0, old_data[3].height * gui.get_scale(node).y, 0))
			end
			break
		end
	end
	if text == "" then return end
	local settings = {
		parent = node,
		color = gui.get_color(node),
		align = ({
			[gui.PIVOT_N] = richtext.ALIGN_CENTER,
			[gui.PIVOT_CENTER] = richtext.ALIGN_CENTER,
			[gui.PIVOT_S] = richtext.ALIGN_CENTER,
			[gui.PIVOT_E] = richtext.ALIGN_RIGHT,
		})[gui.get_pivot(node)],
		valign = ({
			[gui.PIVOT_W] = richtext.VALIGN_MIDDLE,
			[gui.PIVOT_CENTER] = richtext.VALIGN_MIDDLE,
			[gui.PIVOT_E] = richtext.VALIGN_MIDDLE,
			[gui.PIVOT_SW] = richtext.VALIGN_BOTTOM,
		})[gui.get_pivot(node)],
		combine_words = true,
	}
	if base_scale then
		settings.line_spacing = 0
	else
		settings.width = gui.get_size(node).x
	end
	local output, metrics = richtext.create(text, "main", settings)
	table.insert(self.rich_text_nodes, {node, output, metrics, settings})
	if base_scale then
		if metrics.width > base_width then
			gui.set_scale(node, base_width / metrics.width * vmath.vector3(base_scale))
		else
			gui.set_scale(node, vmath.vector3(base_scale))
		end
	end
	if settings.valign == richtext.VALIGN_BOTTOM then
		gui.set_position(node, gui.get_position(node) + vmath.vector3(0, metrics.height * gui.get_scale(node).y, 0))
	end
end

function Engine.update_options_dropdown_button(button)
	if button.over_now then
		gui.set_color(button.node, vmath.vector4(.9, .9, .85, 1))
	end
	if button.out_now then
		gui.set_color(button.node, vmath.vector4(1, 1, 1, 1))
	end
end

function Engine.pressed_options_dropdown_button(button)
	msg.post("/sound", "play", {id = "click"})
	if not monarch.is_visible("optionsdropdown") then
		monarch.show("optionsdropdown", {no_stack = true})
	end
end

function init(self)
    self.save_dir = sys.get_save_file("Paracosmos", "save")
    self.save = sys.load(self.save_dir)
	
    Game.Options = sys.load(sys.get_save_file("Paracosmos", "options"))
	
	mapper.bind(triggers.KEY_SPACE, "confirm", 1)
	mapper.bind(triggers.KEY_ENTER, "confirm", 1)
	mapper.bind(triggers.KEY_TAB, "cycle", 1)
	mapper.bind(triggers.KEY_BACKSPACE, "cancel", 1)
	mapper.bind(triggers.KEY_ESC, "cancel", 1)
	mapper.bind(triggers.MOUSE_BUTTON_RIGHT, "cancel", 1)

	msg.post("#", "main_menu")
end

function on_message(self, message_id, message, sender)
	if message_id == hash "main_menu" then
        monarch.show("mainmenu", {clear = true}, nil, function()
			if self.save.Party then
				monarch.post("mainmenu", "can_load")
			end
		end)
	elseif message_id == hash "new_game" then
		Game.RNG.world = require "main/rng"
		Game.RNG.world:init()
		Game.Party = {}
		for i = 1, 3 do
			table.insert(Game.Party, Player("hero"))
			Game.Party[i].name = ({"Alex", "Blake", "Cody", "Drew", "Evan"})[i]
			Game.Party[i].iconcolor = ({vmath.vector4(.0, .6, .6, 1), vmath.vector4(.6, 0, .6, 1), vmath.vector4(.6, .6, 0, 1), vmath.vector4(.4, .8, .4, 1), vmath.vector4(.8, .5, .3, 1)})[i]
		end
		Game.Party[1]:AddPerk("skill_heal")
		Game.Party[2]:AddPerk("skill_buff_attack")
        Game.Party[3]:AddPerk("stat_attack")
		monarch.show("loadouteditor")
	elseif message_id == hash "load_game" then
		Game.RNG.world = require "main/rng"
		Game.RNG.world:setState(self.save.RNG.world)
        Game.Party = {}
		for i, save_player in ipairs(self.save.Party) do
			local player = Player("hero")
			table.copy(save_player, player)
			for i2,perk_id in ipairs(save_player.perk_ids) do
				player:AddPerk(perk_id)
			end
            Game.Party[i] = player
		end
		for i, item in ipairs(self.save.Inventory) do
            Game.Inventory[i] = table.deepcopy(content.perks[item.id])
			Game.Inventory[i].amount = item.amount
		end
		monarch.show("loadouteditor")
	elseif message_id == hash "save_game" then
        local Save = {Party = {}, Inventory = {}}
		Save.RNG = {world = Game.RNG.world:getState()}
        for i, player in ipairs(Game.Party) do
			local save_player = {}
			for i2, k in pairs{"name", "icon", "iconcolor", "xp", "level"} do
				save_player[k] = player[k]
			end
			save_player.perk_ids = {}
			for i2,perk in ipairs(player.perks) do
				save_player.perk_ids[i2] = perk.id
			end
			Save.Party[i] = save_player
        end
		for i,item in ipairs(Game.Inventory) do
            Save.Inventory[i] = {
                id = item.id,
				amount = item.amount,
			}
        end
		sys.save(self.save_dir, Save)
	end
end
