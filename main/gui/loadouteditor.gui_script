local gui_colors = {
    perklist = {
        normal = vmath.vector4(.9, .9, 1, 1),
        hover = vmath.vector4(.80, .80, .95, 1),
        selected = vmath.vector4(.65, .65, .9, 1),
    },
    charlist = {
        normal = vmath.vector4(1, .90, .80, 1),
        disabled = vmath.vector4(.8, .80, .80, 1),
        selected = vmath.vector4(.8, .95, .85, 1),
        highlight_lvl = vmath.vector4(0, .7, .8, 1),
    },
    equipbutton = {
        normal = vmath.vector4(.8, 1, .8, 1),
        hover = vmath.vector4(.6, 1, .6, 1),
        disabled = vmath.vector4(.85, .85, .85, 1),
    },
    unequipbutton = {
        normal = vmath.vector4(1, .8, .8, 1),
        hover = vmath.vector4(1, .6, .6, 1),
        disabled = vmath.vector4(.85, .85, .85, 1),
    },
    fightbutton = {
        normal = vmath.vector4(1, .8, .7, 1),
        hover = vmath.vector4(1, .6, .4, 1),
    }
}

function init(self)
    gooey.acquire_input()

    self.perk_list = {}
    self.storeperk_list = Game.Inventory
    self.char_list = Game.Party
    self.logtext = ""
    self.write_log = function(text)
        self.logtext = self.logtext .. "\n" .. text
        Engine.richtext_autoscale(self, gui.get_node("log_text"), self.logtext)
    end

    function self.update_perklist(list)
        for i, item in ipairs(list.items) do
            local perk = item.data
            if bool.truthy(perk) then
                local nodes = item.nodes
                local button = nodes[hash "perkitem_btn"]
                Engine.richtext_autoscale(self, item.nodes[hash "perkitem_text"], perk.name, 0.8, 125)
                local image = nodes[hash "perkitem_image"]
                if perk.icon and Engine.load_texture(self, perk.icon) then
                    gui.set_texture(image, perk.icon)
                    gui.set_color(image, perk.iconcolor or vmath.vector4(1))
                else
                    gui.set_color(image, vmath.vector4(0))
                end
                if self.selected_perk == perk then
                    gui.set_color(button, gui_colors.perklist.selected)
                else
                    gui.set_color(button, gui_colors.perklist.normal)
                end
            end
        end
        if list.over_item and list.over_item.data then
            local over_button = list.over_item.nodes[hash "perkitem_btn"]
            if self.selected_perk_button ~= over_button then
                gui.set_color(over_button, gui_colors.perklist.hover)
            end
            if not (self.selected_perk or self.selected_storeperk) and list.over_item.data then
                Engine.richtext_autoscale(self, gui.get_node("tooltip_text"), GL.GetDesc(list.over_item.data))
            end
        end
        if list.out_item_now and not (self.selected_perk or self.selected_storeperk) then
            Engine.richtext_autoscale(self, gui.get_node("tooltip_text"), "")
        end
        if list.scrolling and self.perk_list_scrollbar then
            self.perk_list_scrollbar.scroll_to(0, list.scroll.y)
        end
    end

    function self.selected_perklist(list)
        local perk = list.selected_item.data
        if not perk then return end
        local button = list.selected_item.nodes[hash "perkitem_btn"]
        if self.selected_perk_button or self.selected_storeperk_button then
            if self.selected_perk_button ~= button then --deselect previous perk when clicking new one
                msg.post("/sound", "play", {id = "click"})
                self.deselect_perk(self.selected_perk_button)
            else --click again to remove
                self.press_unequipbutton({node = gui.get_node("unequipbutton")})
                return --do not fallthrough to selection
            end
        else
            msg.post("/sound", "play", {id = "click"})
        end
        self.selected_perk_button = button
        self.selected_perk = perk
        local storeperk_at = table.find_if(self.storeperk_list, function(storeperk) return storeperk.id == perk.id end)
        if storeperk_at then
            self.selected_storeperk = self.storeperk_list[storeperk_at]
            self.selected_storeperk_button = self.storeperk_list_gui.items[storeperk_at].nodes[hash "storeperkitem_btn"]
        end
        Engine.richtext_autoscale(self, gui.get_node("tooltip_text"), GL.GetDesc(perk))
        self:do_gooey()
    end

    function self.scrolled_perk(scrollbar)
        self.perk_list_gui.scroll_to(scrollbar.scroll.x, scrollbar.scroll.y)
    end

    self.deselect_perk = function(button)
        if self.selected_perk_button then
            gui.set_color(self.selected_perk_button, (button == self.selected_perk_button) and gui_colors.perklist.hover or gui_colors.perklist.normal)
        end
        if self.selected_storeperk_button then
            gui.set_color(self.selected_storeperk_button, (button == self.selected_storeperk_button) and gui_colors.perklist.hover or gui_colors.perklist.normal)
        end
        if not button then
            Engine.richtext_autoscale(self, gui.get_node("tooltip_text"), "")
        end
        self.selected_perk_button = nil
        self.selected_perk = nil
        self.selected_storeperk_button = nil
        self.selected_storeperk = nil
    end

    function self.update_storeperklist(list)
        for i, item in ipairs(list.items) do
            local button = item.nodes[hash "storeperkitem_btn"]
            local storeperk = item.data
            if bool.truthy(storeperk) then
                Engine.richtext_autoscale(self, item.nodes[hash "storeperkitem_text"], storeperk.name .. " x" .. storeperk.amount, 0.8, 125)
                local image = item.nodes[hash "storeperkitem_image"]
                if storeperk.icon and Engine.load_texture(self, storeperk.icon) then
                    gui.set_texture(image, storeperk.icon)
                    gui.set_color(image, storeperk.iconcolor or vmath.vector4(1))
                else
                    gui.set_color(image, vmath.vector4(0))
                end
                if self.selected_storeperk == storeperk then
                    gui.set_color(button, gui_colors.perklist.selected)
                else
                    gui.set_color(button, gui_colors.perklist.normal)
                end
            end
        end
        if list.over_item and list.over_item.data then
            local over_button = list.over_item.nodes[hash "storeperkitem_btn"]
            if self.selected_storeperk_button ~= over_button then
                gui.set_color(over_button, gui_colors.perklist.hover)
            end
            if not (self.selected_perk or self.selected_storeperk) and list.over_item.data then
                Engine.richtext_autoscale(self, gui.get_node("tooltip_text"), GL.GetDesc(list.over_item.data))
            end
        end
        if list.out_item_now and not (self.selected_perk or self.selected_storeperk) then
            Engine.richtext_autoscale(self, gui.get_node("tooltip_text"), "")
        end
        if list.scrolling and self.perk_list_scrollbar then
            self.perk_list_scrollbar.scroll_to(0, list.scroll.y)
        end
    end

    function self.selected_storeperklist(list)
        if not list.selected_item.data then return end
        local data = list.selected_item.data
        local button = list.selected_item.nodes[hash "storeperkitem_btn"]
        if self.selected_perk_button or self.selected_storeperk_button then
            if self.selected_storeperk_button ~= button then --deselect previous perk when clicking new one
                msg.post("/sound", "play", {id = "click"})
                self.deselect_perk(self.selected_storeperk_button)
            else --click again to add
                self.press_equipbutton({node = gui.get_node("equipbutton")})
                return --do not fallthrough to selection
            end
        else
            msg.post("/sound", "play", {id = "click"})
        end
        self.selected_storeperk_button = button
        self.selected_storeperk = data
        local perk_at = table.find_if(self.perk_list, function(perk) return perk.id == data.id end)
        if perk_at then
            self.selected_perk = self.perk_list[perk_at]
            self.selected_perk_button = self.perk_list_gui.items[perk_at].nodes[hash "perkitem_btn"]
        end
        Engine.richtext_autoscale(self, gui.get_node("tooltip_text"), GL.GetDesc(data))
        self:do_gooey()
    end

    function self.scrolled_storeperk(scrollbar)
        self.perk_list_gui.scroll_to(scrollbar.scroll.x, scrollbar.scroll.y)
    end
    
    local function count_skill_slots (char)
        local skill_slots = {}
        for i, perk in ipairs(char.perks) do
            if perk.skill_type then
                skill_slots[perk.skill_type] = (skill_slots[perk.skill_type] or 0) + 1
            end
        end
        return skill_slots
    end

    function self.update_charlist(list)
        for i, item in ipairs(list.items) do
            local char = item.data
            if bool.truthy(char) then
                local nodes = item.nodes
                gui.set_color(nodes[hash "charitem_btn"], (self.selected_char and self.selected_char == char) and gui_colors.charlist.selected or gui_colors.charlist.normal)
                Engine.richtext_autoscale(self, nodes[hash "charitem_text"], char.name, 1, 200)
                gui.set_scale(nodes[hash "charitem_xpbar"], vmath.vector3(char.xp / content.formulas.xpscaling(char.level) / 100, 1, 1))
                gui.set_color(nodes[hash "charitem_xptext"], vmath.vector3(0, 1, 0.5) * (char.xp / content.formulas.xpscaling(char.level) / 100) + vmath.vector3(0, 0, 0.5))
                Engine.richtext_autoscale(self, nodes[hash "charitem_xptext"], "XP: " .. char.xp .. "/" .. (content.formulas.xpscaling(char.level) * 100), 0.4, 200)
                gui.set_color(nodes[hash "charitem_lvltext"], (char:SumLevelsSpent() < char.level) and gui_colors.charlist.highlight_lvl or vmath.vector3(0, 0, 0, 1))
                Engine.richtext_autoscale(self, nodes[hash "charitem_lvltext"], "Level: " .. char:SumLevelsSpent() .. "/" .. char.level, 1, 220)
                local image = nodes[hash "charitem_image"]
                if item.data.icon and Engine.load_texture(self, char.icon) then
                    gui.set_texture(image, char.icon)
                    gui.set_color(image, char.iconcolor or vmath.vector4(1))
                else
                    gui.set_color(image, vmath.vector4(0))
                end
            end
        end
        if list.scrolling and self.char_list_scrollbar then
            self.char_list_scrollbar.scroll_to(0, list.scroll.y)
        end
        if self.selected_char then
            Engine.richtext_autoscale(self, gui.get_node("statsheet_text"), string.gsub(
                "Lv. {level} {class}\n<color=red>Max HP: {hpmax}</color>\n<color=red>Atk: {attack}  </color><color=purple>Mat: {magicattack}  </color><color=brown>Acc: {accuracy}</color>\n<color=teal><color=blue>Def: {defense}  </color>Mdf: {magicdefense}  </color><color=green>Eva: {evasion}</color>\n{skillslots}"
                , "%{(.-)%}", function(s)
                if s == "class" and not self.selected_char.class then
                    return "Human"
                elseif s == "skillslots" then
                    local filled_skill_slots = count_skill_slots(self.selected_char)
                    return "Attack Skills: " .. (filled_skill_slots.attack or 0) .. "/" .. self.selected_char.skill_slots.attack  .. "\nSupport Skills: " .. (filled_skill_slots.support or 0) .. "/" .. self.selected_char.skill_slots.support
                end
                return GL.FormatDescField(self.selected_char, s)
            end), nil) --nil blocks second output from gsub
        end
    end

    function self.selected_charlist(list)
        if not list.selected_item.data then return end
        if self.selected_char ~= list.selected_item.data then
            msg.post("/sound", "play", {id = "click"})
            self.set_selected_char(list.selected_item.data, list.selected_item.nodes)
        end
    end

    function self.scrolled_char(scrollbar)
        self.char_list_gui.scroll_to(scrollbar.scroll.x, scrollbar.scroll.y)
    end

    function self.set_selected_char(char, char_gui)
        self:deselect_perk()
        if self.selected_char then
            gui.set_visible(self.selected_char_gui[hash "charitem_pointer"], false)
        end
        self.selected_char = char
        self.selected_char_gui = char_gui
        Engine.richtext_autoscale(self, gui.get_node("perklist_title"), string.format("%s's perks", char.name), 0.8, 175)
        gui.set_visible(char_gui[hash "charitem_pointer"], true)
        self.perk_list = char.perks
        self:do_gooey()
    end

    function self.update_equipbutton(button)
        local cannot_equip = false
        local over_msg = false
        if self.selected_perk then
            cannot_equip = true
            if self.selected_storeperk and button.over then
                over_msg = true
                Engine.richtext_autoscale(self, gui.get_node("equipmsg_text"), "Already equipped!")
            end
        elseif self.selected_storeperk then
            if self.selected_storeperk.CanEquip and not self.selected_storeperk:CanEquip(self.selected_char) then
                cannot_equip = true
                if not self.selected_perk and button.over then
                    over_msg = true
                    Engine.richtext_autoscale(self, gui.get_node("equipmsg_text"), "Requirements not met!")
                end
            elseif self.selected_char and (self.selected_char:SumLevelsSpent() + (self.selected_storeperk.cost or 1) > self.selected_char.level) then
                cannot_equip = true
                if not self.selected_perk and button.over then
                    over_msg = true
                    Engine.richtext_autoscale(self, gui.get_node("equipmsg_text"), "Not enough levels!")
                end
            elseif self.selected_storeperk.skill_type then
                local skill_slots = count_skill_slots(self.selected_char)
                if (skill_slots[self.selected_storeperk.skill_type] or 0) + 1 > self.selected_char.skill_slots[self.selected_storeperk.skill_type] then
                    cannot_equip = true
                    if not self.selected_perk and button.over then
                        over_msg = true
                        Engine.richtext_autoscale(self, gui.get_node("equipmsg_text"), "All " .. string.firstupper(self.selected_storeperk.skill_type) .. " slots full!")
                    end
                end
            end
        end
        if cannot_equip then
            gui.set_color(button.node, gui_colors.equipbutton.disabled)
        else
            if button.over then
                gui.set_color(button.node, gui_colors.equipbutton.hover)
            else
                gui.set_color(button.node, gui_colors.equipbutton.normal)
            end
        end
        if not over_msg then
            Engine.richtext_autoscale(self, gui.get_node("equipmsg_text"), "")
        end
        if self.selected_storeperk then
            gui.set_alpha(button.node, 1)
        else
            gui.set_alpha(button.node, 0)
        end
        self.cannot_equip = cannot_equip
    end

    function self.press_equipbutton(button)
        if self.selected_storeperk and not self.selected_perk and not self.cannot_equip then
            local perk = self.selected_storeperk
            self.selected_char:AddPerk(perk.id)
            perk.amount = perk.amount - 1
            if perk.amount == 0 then
                table.remove_value(self.storeperk_list, perk)
                self.selected_storeperk_button = nil
                self.selected_storeperk = nil
            end
            msg.post("/sound", "play", {id = "click"})
            self.selected_perk = self.perk_list[#self.perk_list]
            self:do_gooey()
            self.selected_perk_button = self.perk_list_gui.items[#self.perk_list].nodes[hash "perkitem_btn"]
            self:do_gooey()
        end
    end

    function self.update_unequipbutton(button)
        if button.over then
            gui.set_color(button.node, gui_colors.unequipbutton.hover)
        else
            gui.set_color(button.node, gui_colors.unequipbutton.normal)
        end
        if self.selected_perk then
            gui.set_alpha(button.node, 1)
        else
            gui.set_alpha(button.node, 0)
        end
    end
    
    local function add_storeperk(perk)
        local storeperk = self.storeperk_list[table.find_if(self.storeperk_list, function(storeperk) return storeperk.id == perk.id end)]
        if storeperk then
            storeperk.amount = storeperk.amount + 1
        else
            perk.amount = 1
            table.insert(self.storeperk_list, perk)
            self.selected_storeperk = self.storeperk_list[#self.storeperk_list]
            self.selected_storeperk_button = self.storeperk_list_gui.items[#self.storeperk_list].nodes[hash "storeperkitem_btn"]
        end
    end

    function self.press_unequipbutton(button)
        if self.selected_perk then
            local perk = self.selected_perk
            self.selected_char:RemovePerk(perk)
            self.selected_perk = nil
            self.selected_perk_button = nil
            add_storeperk(perk)
            msg.post("/sound", "play", {id = "click"})
            local perk_removed
            repeat
                perk_removed = false
                for i,other_perk in ipairs(array.reverse(self.selected_char.perks)) do
                    if other_perk.CanEquip and not other_perk:CanEquip(self.selected_char) then
                        self.selected_char:RemovePerk(other_perk)
                        self.write_log(self.selected_char.name .. " removed " .. other_perk.name .. " due to requirements no longer being met")
                        add_storeperk(other_perk)
                        perk_removed = true
                        break
                    end
                end
            until not perk_removed
            self:do_gooey()
        end
    end

    function self.update_fightbutton(button)
        if button.over_now then
            gui.set_color(button.node, gui_colors.fightbutton.hover)
        end
        if button.out_now then
            gui.set_color(button.node, gui_colors.fightbutton.normal)
        end
    end

    function self.press_fightbutton(button)
        msg.post("/sound", "play", {id = "click"})
        monarch.show("levelselect")
    end

    function self.do_gooey(self, action_id, action)
        self.perk_list_gui = gooey.dynamic_list("perklist_bg", "perklist_stencil", "perkitem_bg", self.perk_list, action_id, action, nil, self.selected_perklist, self.update_perklist)
        self.storeperk_list_gui = gooey.dynamic_list("storeperklist_bg", "storeperklist_stencil", "storeperkitem_bg", self.storeperk_list, action_id, action, nil, self.selected_storeperklist, self.update_storeperklist)
        self.char_list_gui = gooey.dynamic_list("charlist_bg", "charlist_stencil", "charitem_bg", self.char_list, action_id, action, nil, self.selected_charlist, self.update_charlist)
        gui.set_alpha(gui.get_node("charscroll_bg"), 0)
        if self.perk_list_gui.data_size > 15 then
            gui.set_position(gui.get_node("perklist_bg"), vmath.vector3(355, 648, 0))
            gui.set_alpha(gui.get_node("perkscroll_bg"), 1)
            gui.set_size(gui.get_node("perkscroll_handle"), vmath.vector3(14, 648 * 15 / self.perk_list_gui.data_size, 0))
            self.perk_list_scrollbar = gooey.vertical_scrollbar("perkscroll_handle", "perkscroll_bg", action_id, action, self.scrolled_perk)
        else
            gui.set_position(gui.get_node("perklist_bg"), vmath.vector3(355, 648 - 620 / 30 * (15 - self.perk_list_gui.data_size), 0))
            gui.set_alpha(gui.get_node("perkscroll_bg"), 0)
        end
        if self.storeperk_list_gui.data_size > 15 then
            gui.set_position(gui.get_node("storeperklist_bg"), vmath.vector3(785, 648, 0))
            gui.set_alpha(gui.get_node("storeperkscroll_bg"), 1)
            gui.set_size(gui.get_node("storeperkscroll_handle"), vmath.vector3(14, 648 * 15 / self.storeperk_list_gui.data_size, 0))
            self.storeperk_list_scrollbar = gooey.vertical_scrollbar("storeperkscroll_handle", "storeperkscroll_bg", action_id, action, self.scrolled_perk)
        else
            gui.set_position(gui.get_node("storeperklist_bg"), vmath.vector3(785, 648 - 620 / 30 * (15 - self.storeperk_list_gui.data_size), 0))
            gui.set_alpha(gui.get_node("storeperkscroll_bg"), 0)
        end
        if self.char_list_gui.data_size > 5 then
            gui.set_position(gui.get_node("charlist_bg"), vmath.vector3(125, 648, 0))
            gui.set_alpha(gui.get_node("charscroll_bg"), 1)
            gui.set_size(gui.get_node("charscroll_handle"), vmath.vector3(18, 648 * 5 / self.char_list_gui.data_size, 0))
            self.char_list_scrollbar = gooey.vertical_scrollbar("charscroll_handle", "charscroll_bg", action_id, action, self.scrolled_char)
        else
            gui.set_position(gui.get_node("charlist_bg"), vmath.vector3(125, 648 - 324 / 5 * (5 - self.char_list_gui.data_size), 0))
            gui.set_alpha(gui.get_node("charscroll_bg"), 0)
        end
        gooey.button("equipbutton", action_id, action, self.press_equipbutton, self.update_equipbutton)
        gooey.button("unequipbutton", action_id, action, self.press_unequipbutton, self.update_unequipbutton)
        gooey.button("fightbutton", action_id, action, self.press_fightbutton, self.update_fightbutton)
        gooey.button("optionsbutton", action_id, action, Engine.pressed_options_dropdown_button, Engine.update_options_dropdown_button)
    end

    self:do_gooey()

    self.set_selected_char(self.char_list[1], self.char_list_gui.items[1].nodes)
end

function on_input(self, action_id, action)
    self:do_gooey(action_id, action)
end
